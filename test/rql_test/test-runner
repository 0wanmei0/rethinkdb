#!/usr/bin/python

from yaml import load
from os import walk
from sys import argv
from getopt import getopt
from subprocess import call, Popen
from time import sleep
import random
import socket
import re

class TestGroup:
    def __init__(self, path, group):
        self.path = path
        self.group = group

    def __iter__(self):
        return iter(self.group['tests'])

# Walk the test tree and get an object representing all
# the test data from the yaml files. Each yaml file defines
# a test group. The test groups themselves are nested by
# their directory structure.
def get_test_structure():
    tests = {}

    for root, dirs, files in walk("src"):
        
        # Find the nested group location from the root
        path = root.split('/')[1:]
        cur = tests
        for level in path:
            if not cur.has_key(level):
                cur[level] = {}
            cur = cur[level]
        
        # Parse and insert the yaml structures
        for name in filter(lambda name: name.endswith('.yaml'), files):
            test_group = load(open(root+'/'+name))
            leaf = name.partition('.')[0]
            cur[leaf] = TestGroup(path+[leaf], test_group)

    return tests

def build_test_scripts():
    tests = get_test_structure()

    build_script(tests, 'py')
    build_script(tests, 'js')
    build_script(tests, 'rb')

def myrepr(string, lang):
    if isinstance(string, unicode):
        if lang == 'py': 
            return repr(string)
        else:
            return '"'+string+'"'
    if isinstance(string, bool):
        if lang == 'js':
            return repr('true') if string else repr('false')
    return repr(str(string))

def build_script(tests, lang):
    script = open('build/test.'+lang, 'w+')
    
    driver = open('drivers/driver.'+lang)

    if lang is 'py':
        comment = '#'
        translate = lambda x: x
    elif lang is 'js':
        comment = '//'
        translate = lambda x: re.sub('_[a-z]', lambda m: m.group()[1].upper(), x)
    elif lang is 'rb':
        comment = '#'
        translate = lambda x: re.sub(':', '=>', x)

    # The driver is the head of the file
    script.write(driver.read())

    # Now append the tests
    def walk(level, ln):
        for name,sub in level.iteritems():
            script.write(comment*ln + ' ' + name + '\n')

            if isinstance(sub, TestGroup):
                script.write(comment*ln + '  ' + sub.group['desc'] + '\n\n')

                i = 0
                for test in sub:
                    i = i + 1
                    # This test may define variables to be used later
                    if 'def' in test:
                        define = test['def']
                        if isinstance(define, dict):
                            if lang in define:
                                define = define[lang]
                            else:
                                define = None
                        else:
                            define = translate(define)

                        if define:
                            script.write("define("+myrepr(define, lang)+")\n")
                        continue

                    if lang in test:
                        generic_code = False
                        t = test[lang]
                    elif 'cd' in test:
                        generic_code = True
                        t = test['cd']
                    else:
                        t = None
                        print "Missing test for %s: %s-%d" % (lang, '/'.join(sub.path), i)

                    if t:
                        # print "Generating test for %s: %s-%d" % (lang, '/'.join(sub.path), i)
                        if 'ot' in test:
                            expected = translate(str(test['ot']))
                    
                        # Test may be a dict providing specific values for this language
                        if isinstance(t, dict):
                            code = t['code']
                            if 'ot' in t:
                                expected = t['ot']
                        else:
                            code = t

                        # Test may be a list of syntactically different but practically similar variants 
                        if not isinstance(code, list):
                            code = [code]

                        if generic_code:
                            code = map(translate, code)

                        # Write out each variant as a separate test
                        for variant in code:
                            test = "test("+myrepr(variant, lang)+", "+myrepr(expected, lang)+", '"+('/'.join(sub.path))+"-"+str(i)+"')\n"
                            script.write(test)
            else:
                script.write('\n')
                walk(sub, ln+1)
            script.write('\n'+comment*ln + '\n')
                
    walk(tests, 1)

def find_available_port_offset(port_list):
    max_loop = 10
    offset_max = 65535 - max(port_list)
    for i in range(max_loop):
        offset = random.randint(0, offset_max)
        good = True
        for port in port_list:
            if not port_available(port + offset):
                good = False
                break
        if good:
            return offset

def port_available(port):
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.bind(("127.0.0.1",port))
        s.close()
    except socket.error:
        return False
    return True
        

class RethinkDBTestServers:
    def __init__(self):
        self.start()

    def start(self): 
        cpp_port_offset = find_available_port_offset([28015, 28016])
        self.cpp_port = 28015 + cpp_port_offset
        self.cpp_server = Popen(['../../build/debug/rethinkdb',
                                 '--driver-port', str(self.cpp_port - 1),
                                 '--http-port=0',
                                 '--cluster-port=0'])
        js_port_offset = find_available_port_offset([8080, 28016])
        self.js_server = Popen(['node', '../../rqljs/build/rqljs', str(js_port_offset)])
        self.js_port = 28016 + js_port_offset
        sleep(0.1)

    def stop(self):
        self.cpp_server.terminate()
        self.js_server.terminate()
        self.clear_data()

    def clear_data(self):
        call(['rm', 'rethinkdb-data']) # JS server data
        call(['rm', '-r', 'rethinkdb_data'])

    def restart(self):
        self.stop()
        self.start()

def run_tests(lang, servers):
    if lang is 'py':
        interpreter = 'python'
    elif lang is 'js':
        interpreter = 'node'
    elif lang is 'rb':
        interpreter = 'ruby'
    else:
        exit("Unkown language: " + lang)

    print "Running "+lang+" tests\n"
    call([interpreter, 'build/test.'+lang, str(servers.js_port), str(servers.cpp_port)])
    print "Finished running "+lang+" tests\n"

# Run the tests
def run():
    servers = RethinkDBTestServers()
    run_tests('py', servers)
    servers.restart()
    run_tests('js', servers)
    servers.restart()
    run_tests('rb', servers)
    servers.stop()

def run_py():
    servers = RethinkDBTestServers()
    run_tests('py', servers)
    servers.stop()

def run_rb():
    servers = RethinkDBTestServers()
    run_tests('rb', servers)
    servers.stop()

def run_js():
    servers = RethinkDBTestServers()
    run_tests('js', servers)
    servers.stop()


if __name__ == '__main__':
    eval(argv[1]+'()')

#!/usr/bin/env python
import sys

def generate_make_serializable_macro(nfields):
    print "#define RDB_MAKE_SERIALIZABLE_%d(type_t%s) \\" % \
        (nfields, "".join(", field%d" % (i+1) for i in xrange(nfields)))
    print "    inline void serialize(cluster_outpipe_t *pipe, const type_t &m) { \\"
    for i in xrange(nfields):
        print "        ::serialize(pipe, m.field%d); \\" % (i+1)
    print "    } \\"
    print "    inline int ser_size(const type_t &m) { \\"
    print "        int total = 0; \\"
    for i in xrange(nfields):
        print "        total += ::ser_size(m.field%d); \\" % (i+1)
    print "        return total; \\"
    print "    } \\"
    print "    inline void unserialize(cluster_inpipe_t *pipe, type_t *m) { \\"
    for i in xrange(nfields):
        print "        ::unserialize(pipe, &m->field%d); \\" % (i+1)
    print "    } \\"
    # See the note in the comment below.
    print "    extern int dont_use_RDB_MAKE_SERIALIZABLE_within_a_class_body;"

def generate_make_me_serializable_macro(nfields):
    print "#define RDB_MAKE_ME_SERIALIZABLE_%d(type_t%s) \\" % \
        (nfields, "".join(", field%d" % (i+1) for i in xrange(nfields)))
    print "    static void serialize(cluster_outpipe_t *pipe, const type_t &m) { \\"
    for i in xrange(nfields):
        print "        ::serialize(pipe, m.field%d); \\" % (i+1)
    print "    } \\"
    print "    static int ser_size(const type_t &m) { \\"
    print "        int total = 0; \\"
    for i in xrange(nfields):
        print "        total += ::ser_size(m.field%d); \\" % (i+1)
    print "        return total; \\"
    print "    } \\"
    print "    static void unserialize(cluster_inpipe_t *pipe, type_t *m) { \\"
    for i in xrange(nfields):
        print "        ::unserialize(pipe, &m->field%d); \\" % (i+1)
    print "    }"

if __name__ == "__main__":

    print "#ifndef __CLUSTERING_SERIALIZE_MACROS_HPP__"
    print "#define __CLUSTERING_SERIALIZE_MACROS_HPP__"
    print

    print "/* This file is automatically generated by '%s'." % " ".join(sys.argv)
    print "Please modify '%s' instead of modifying this file.*/" % sys.argv[0]
    print

    print "#include \"clustering/serialize.hpp\""
    print

    print """
/* The purpose of these macros is to make it easier to serialize and
unserialize data types that consist of a simple series of fields, each of which
is serializable. Suppose we have a type "struct point_t { int x, y; }" that we
want to be able to serialize. To make it serializable automatically, either
write RDB_MAKE_SERIALIZABLE_2(point_t, x, y) at the global scope or write
RDB_MAKE_ME_SERIALIZABLE(point_t, x, y) within the body of the point_t type.
The reason for the second form is to make it possible to serialize template
types. There is at present no non-intrusive way to use these macros to
serialize template types; this is less-than-ideal, but not worth fixing right
now.

A note about "dont_use_RDB_MAKE_SERIALIZABLE_within_a_class_body": It's wrong
to invoke RDB_MAKE_SERIALIZABLE_*() within the body of a class. You should
invoke it at global scope after the class declaration, or use
RDB_MAKE_ME_SERIALIZABLE_*() instead. In order to force the compiler to catch
this error, we declare a dummy "extern int" in RDB_MAKE_ME_SERIALIZABLE_*().
This is a noop at the global scope, but produces a (somewhat weird) error in
the class scope. */
    """.strip()
    print

    for nfields in xrange(20):
        generate_make_serializable_macro(nfields)
        generate_make_me_serializable_macro(nfields)
        print

    print "#endif /* __CLUSTERING_SERIALIZE_MACROS_HPP__ */"

#ifndef CONCURRENCY_FIFO_ENFORCER_HPP_
#define CONCURRENCY_FIFO_ENFORCER_HPP_

#include <map>
#include <utility>

#include "concurrency/mutex_assertion.hpp"
#include "concurrency/queue/passive_producer.hpp"
#include "concurrency/signal.hpp"
#include "containers/intrusive_priority_queue.hpp"
#include "perfmon/perfmon.hpp"
#include "rpc/serialize_macros.hpp"
#include "stl_utils.hpp"
#include "timestamps.hpp"
#include "utils.hpp"

class cond_t;
class signal_t;

namespace unittest {
void run_queue_equivalence_test();
}

/* `fifo_enforcer.hpp` contains facilities for enforcing that objects pass
through a checkpoint in the same order that they passed through a previous
checkpoint. The objects in transit between the checkpoints are identified by
"tokens", of the types `fifo_enforcer_read_token_t` and
`fifo_enforcer_write_token_t`. Read tokens are allowed to be reordered relative
to each other but not relative to write tokens. */

/* A clinic can be used as metaphor for how `fifo_enforcer_{source,sink}_t` are used.
 * First you get an appointment (`fifo_enforcer_source_t::enter_{read,write}()`), then you
 * come to a waiting room (construct `fifo_enforcer_sink_t::exit_{read,write}_t`), where
 * you are notified when the doctor is ready to see you (the `exit_{read,write}_t` object
 * gets pulsed). When you finish seeing the doctor (destroy the `exit_{read,write}_t`),
 * the person who has the next appointment is notified.  If you leave the waiting room
 * (destroy the `exit_{read,write}_t` before it is pulsed), you forfeit your appointment
 * and place in line.
 *
 * The metaphor breaks down in that, if you don't show up for your appointment, all the
 * later appointments are delayed indefinitely. That means that if you never construct a
 * `exit_{read,write}_t` for a token, users of all later tokens will never get to go.
 */
class fifo_enforcer_read_token_t {
public:
    fifo_enforcer_read_token_t() THROWS_NOTHING { }
    explicit fifo_enforcer_read_token_t(state_timestamp_t t) THROWS_NOTHING :
        timestamp(t) { }
    state_timestamp_t timestamp;
private:
    RDB_MAKE_ME_SERIALIZABLE_1(timestamp);
};

class fifo_enforcer_write_token_t {
public:
    fifo_enforcer_write_token_t() THROWS_NOTHING : timestamp(), num_preceding_reads(-1) { }

    fifo_enforcer_write_token_t(transition_timestamp_t t, int npr) THROWS_NOTHING :
        timestamp(t), num_preceding_reads(npr) { }
    transition_timestamp_t timestamp;
    int64_t num_preceding_reads;
private:
    RDB_MAKE_ME_SERIALIZABLE_2(timestamp, num_preceding_reads);
};

class fifo_enforcer_source_t : public home_thread_mixin_t {
public:
    /* `state_t` represents the internal state of a `fifo_enforcer_source_t`. If
    you want to initialize a `fifo_enforcer_sink_t` in such a way that it
    "skips" all of the tokens that have already been generated by the
    `fifo_enforcer_source_t`, then call `get_state()` on the
    `fifo_enforcer_source_t` and pass the result to the `fifo_enforcer_sink_t`
    constructor. */
    class state_t {
    public:
        state_t() THROWS_NOTHING { }
        state_t(state_timestamp_t ts, int64_t nr) THROWS_NOTHING : timestamp(ts), num_reads(nr) { }
        state_timestamp_t timestamp;
        int64_t num_reads;
    private:
        RDB_MAKE_ME_SERIALIZABLE_2(timestamp, num_reads);
    };

    fifo_enforcer_source_t() THROWS_NOTHING :
        state(state_timestamp_t::zero(), 0) { }

    /* Enters the FIFO for read. Does not block. */
    fifo_enforcer_read_token_t enter_read() THROWS_NOTHING;

    /* Enters the FIFO for write. Does not block. */
    fifo_enforcer_write_token_t enter_write() THROWS_NOTHING;

    state_t get_state() THROWS_NOTHING {
        return state;
    }

private:
    mutex_assertion_t lock;
    state_t state;
    DISABLE_COPYING(fifo_enforcer_source_t);
};

class fifo_enforcer_sink_t : public home_thread_mixin_t {
public:
    class exit_read_t : public signal_t, public intrusive_priority_queue_node_t<exit_read_t> {
    public:
        exit_read_t() THROWS_NOTHING;

        /* Calls `begin()` */
        exit_read_t(fifo_enforcer_sink_t *, fifo_enforcer_read_token_t) THROWS_NOTHING;

        /* Calls `end()` if appropriate */
        ~exit_read_t() THROWS_NOTHING;

        void begin(fifo_enforcer_sink_t *, fifo_enforcer_read_token_t) THROWS_NOTHING;
        void end() THROWS_NOTHING;

    private:
        friend class fifo_enforcer_sink_t;

        /* Constructs a dummy. */
        exit_read_t(fifo_enforcer_read_token_t tok) THROWS_NOTHING :
            token(tok), is_dummy(true) { }

        bool is_higher_priority_than(exit_read_t *other) {
            return token.timestamp < other->token.timestamp;
        }

        /* `parent` is `NULL` before `begin()` is called. After `end()` is
        called, `parent` remains non-`NULL` but `ended` is set to `true` */
        fifo_enforcer_sink_t *parent;
        bool ended;

        fifo_enforcer_read_token_t token;

        /* If an `exit_read_t` is destroyed while still on the queue, it
        allocates a dummy `exit_read_t` on the heap to take its place. */
        bool is_dummy;
    };

    class exit_write_t : public signal_t, public intrusive_priority_queue_node_t<exit_write_t> {
    public:
        exit_write_t() THROWS_NOTHING;

        /* Calls `begin()` */
        exit_write_t(fifo_enforcer_sink_t *, fifo_enforcer_write_token_t) THROWS_NOTHING;

        /* Calls `end()` if appropriate */
        ~exit_write_t() THROWS_NOTHING;

        void begin(fifo_enforcer_sink_t *, fifo_enforcer_write_token_t) THROWS_NOTHING;
        void end() THROWS_NOTHING;

    private:
        friend class fifo_enforcer_sink_t;

        /* Constructs a dummy. */
        exit_write_t(fifo_enforcer_write_token_t tok) THROWS_NOTHING :
            token(tok), is_dummy(true) { }

        bool is_higher_priority_than(exit_write_t *other) {
            return token.timestamp < other->token.timestamp;
        }

        /* `parent` is `NULL` before `begin()` is called. After `end()` is
        called, `parent` remains non-`NULL` but `ended` is set to `true` */
        fifo_enforcer_sink_t *parent;
        bool ended;

        fifo_enforcer_write_token_t token;

        /* If an `exit_write_t` is destroyed while still on the queue, it
        allocates a dummy `exit_write_t` on the heap to take its place. */
        bool is_dummy;
    };

    fifo_enforcer_sink_t() THROWS_NOTHING :
        state(state_timestamp_t::zero(), 0) { }

    explicit fifo_enforcer_sink_t(fifo_enforcer_source_t::state_t init) THROWS_NOTHING :
        state(init) { }

    ~fifo_enforcer_sink_t() THROWS_NOTHING;

private:
    void pump() THROWS_NOTHING;
    void finish_a_reader(fifo_enforcer_read_token_t token) THROWS_NOTHING;
    void finish_a_writer(fifo_enforcer_write_token_t token) THROWS_NOTHING;

    mutex_assertion_t lock;
    fifo_enforcer_source_t::state_t state;
    intrusive_priority_queue_t<exit_read_t> waiting_readers;
    intrusive_priority_queue_t<exit_write_t> waiting_writers;
    DISABLE_COPYING(fifo_enforcer_sink_t);
};

#endif /* CONCURRENCY_FIFO_ENFORCER_HPP_ */

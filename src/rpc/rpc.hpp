#ifndef __RPC_RPC_HPP__
#define __RPC_RPC_HPP__

/* This file is automatically generated by '../scripts/generate_rpc_templates.py'.
Please modify '../scripts/generate_rpc_templates.py' instead of modifying this file.*/

#include "rpc/serialize/serialize.hpp"
#include "rpc/serialize/serialize_macros.hpp"
#include "concurrency/cond_var.hpp"
#include "rpc/core/cluster.hpp"
#include "rpc/core/peer.hpp"

template<class proto_t> class async_mailbox_t {
    // BOOST_STATIC_ASSERT(false);
};

template<class proto_t> class sync_mailbox_t;

struct rpc_peer_killed_exc_t : public std::exception {
    const char *what() throw () {
        return "Peer killed during rpc\n";
    }
};

template<>
class async_mailbox_t< void() > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void() > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call() {
            message_t m;
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {
                throw rpc_peer_killed_exc_t();
            } catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t()
            { }
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             int size = 0;
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        p->done();
        callback();
        // Args become invalid here because extra_storage dies
    }

    boost::function< void() > callback;
    void run(cluster_message_t *cm) {
        callback();
    }
};

template<>
class sync_mailbox_t< void() > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void() > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call() {
            call_message_t m;
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<bool>, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
                void run(cluster_message_t *msg) {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t()
            { }
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void() > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        callback();
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback();
        m->reply_to.send(&rm);
    }
};

template<class ret_t>
class sync_mailbox_t< ret_t() > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t() > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call() {
            call_message_t m;
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    ret_t ret;
                    // No extra storage because this is a return, not a call
                    global_unserialize(p, NULL, &ret);
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    ret_t ret = m->ret;
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t()
            { }
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, ret);
        }
        int ser_size() {
             return global_ser_size(ret);
        }
    };

    boost::function< ret_t() > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        rm.ret = callback();
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback();
        m->reply_to.send(&rm);
    }
};

template<class arg0_t>
class async_mailbox_t< void(arg0_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0) {
            message_t m(arg0);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {
                throw rpc_peer_killed_exc_t();
            } catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0)
            : arg0(arg0) { }
        const arg0_t &arg0;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
        }
        int ser_size() {
             int size = 0;
            size += global_ser_size(arg0);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        p->done();
        callback(arg0);
        // Args become invalid here because extra_storage dies
    }

    boost::function< void(const arg0_t &arg0) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        callback(arg0);
    }
};

template<class arg0_t>
class sync_mailbox_t< void(arg0_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0) {
            call_message_t m(arg0);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<bool>, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
                void run(cluster_message_t *msg) {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0)
            : arg0(arg0) { }
        const arg0_t &arg0;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        callback(arg0);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t>
class sync_mailbox_t< ret_t(arg0_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0) {
            call_message_t m(arg0);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    ret_t ret;
                    // No extra storage because this is a return, not a call
                    global_unserialize(p, NULL, &ret);
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    ret_t ret = m->ret;
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0)
            : arg0(arg0) { }
        const arg0_t &arg0;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, ret);
        }
        int ser_size() {
             return global_ser_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        rm.ret = callback(arg0);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t>
class async_mailbox_t< void(arg0_t, arg1_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1) {
            message_t m(arg0, arg1);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {
                throw rpc_peer_killed_exc_t();
            } catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1)
            : arg0(arg0), arg1(arg1) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
        }
        int ser_size() {
             int size = 0;
            size += global_ser_size(arg0);
            size += global_ser_size(arg1);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        p->done();
        callback(arg0, arg1);
        // Args become invalid here because extra_storage dies
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        callback(arg0, arg1);
    }
};

template<class arg0_t, class arg1_t>
class sync_mailbox_t< void(arg0_t, arg1_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1) {
            call_message_t m(arg0, arg1);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<bool>, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
                void run(cluster_message_t *msg) {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1)
            : arg0(arg0), arg1(arg1) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        callback(arg0, arg1);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1) {
            call_message_t m(arg0, arg1);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    ret_t ret;
                    // No extra storage because this is a return, not a call
                    global_unserialize(p, NULL, &ret);
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    ret_t ret = m->ret;
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1)
            : arg0(arg0), arg1(arg1) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, ret);
        }
        int ser_size() {
             return global_ser_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        rm.ret = callback(arg0, arg1);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) {
            message_t m(arg0, arg1, arg2);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {
                throw rpc_peer_killed_exc_t();
            } catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2)
            : arg0(arg0), arg1(arg1), arg2(arg2) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
        }
        int ser_size() {
             int size = 0;
            size += global_ser_size(arg0);
            size += global_ser_size(arg1);
            size += global_ser_size(arg2);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        p->done();
        callback(arg0, arg1, arg2);
        // Args become invalid here because extra_storage dies
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        callback(arg0, arg1, arg2);
    }
};

template<class arg0_t, class arg1_t, class arg2_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) {
            call_message_t m(arg0, arg1, arg2);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<bool>, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
                void run(cluster_message_t *msg) {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2)
            : arg0(arg0), arg1(arg1), arg2(arg2) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        callback(arg0, arg1, arg2);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) {
            call_message_t m(arg0, arg1, arg2);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    ret_t ret;
                    // No extra storage because this is a return, not a call
                    global_unserialize(p, NULL, &ret);
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    ret_t ret = m->ret;
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2)
            : arg0(arg0), arg1(arg1), arg2(arg2) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, ret);
        }
        int ser_size() {
             return global_ser_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        rm.ret = callback(arg0, arg1, arg2);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) {
            message_t m(arg0, arg1, arg2, arg3);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {
                throw rpc_peer_killed_exc_t();
            } catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
        }
        int ser_size() {
             int size = 0;
            size += global_ser_size(arg0);
            size += global_ser_size(arg1);
            size += global_ser_size(arg2);
            size += global_ser_size(arg3);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        p->done();
        callback(arg0, arg1, arg2, arg3);
        // Args become invalid here because extra_storage dies
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        arg3_t arg3(m->arg3);
        callback(arg0, arg1, arg2, arg3);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) {
            call_message_t m(arg0, arg1, arg2, arg3);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<bool>, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
                void run(cluster_message_t *msg) {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(arg3);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        callback(arg0, arg1, arg2, arg3);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2, m->arg3);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t, arg3_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) {
            call_message_t m(arg0, arg1, arg2, arg3);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    ret_t ret;
                    // No extra storage because this is a return, not a call
                    global_unserialize(p, NULL, &ret);
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    ret_t ret = m->ret;
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(arg3);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, ret);
        }
        int ser_size() {
             return global_ser_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        rm.ret = callback(arg0, arg1, arg2, arg3);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) {
            message_t m(arg0, arg1, arg2, arg3, arg4);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {
                throw rpc_peer_killed_exc_t();
            } catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
        }
        int ser_size() {
             int size = 0;
            size += global_ser_size(arg0);
            size += global_ser_size(arg1);
            size += global_ser_size(arg2);
            size += global_ser_size(arg3);
            size += global_ser_size(arg4);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        p->done();
        callback(arg0, arg1, arg2, arg3, arg4);
        // Args become invalid here because extra_storage dies
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        arg3_t arg3(m->arg3);
        arg4_t arg4(m->arg4);
        callback(arg0, arg1, arg2, arg3, arg4);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<bool>, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
                void run(cluster_message_t *msg) {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(arg3);
             size += global_ser_size(arg4);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        callback(arg0, arg1, arg2, arg3, arg4);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    ret_t ret;
                    // No extra storage because this is a return, not a call
                    global_unserialize(p, NULL, &ret);
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    ret_t ret = m->ret;
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(arg3);
             size += global_ser_size(arg4);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, ret);
        }
        int ser_size() {
             return global_ser_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        rm.ret = callback(arg0, arg1, arg2, arg3, arg4);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) {
            message_t m(arg0, arg1, arg2, arg3, arg4, arg5);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {
                throw rpc_peer_killed_exc_t();
            } catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, arg5);
        }
        int ser_size() {
             int size = 0;
            size += global_ser_size(arg0);
            size += global_ser_size(arg1);
            size += global_ser_size(arg2);
            size += global_ser_size(arg3);
            size += global_ser_size(arg4);
            size += global_ser_size(arg5);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        arg5_t arg5;
        global_unserialize(p, &extra_storage, &arg5);
        p->done();
        callback(arg0, arg1, arg2, arg3, arg4, arg5);
        // Args become invalid here because extra_storage dies
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        arg3_t arg3(m->arg3);
        arg4_t arg4(m->arg4);
        arg5_t arg5(m->arg5);
        callback(arg0, arg1, arg2, arg3, arg4, arg5);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<bool>, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
                void run(cluster_message_t *msg) {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, arg5);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(arg3);
             size += global_ser_size(arg4);
             size += global_ser_size(arg5);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        arg5_t arg5;
        global_unserialize(p, &extra_storage, &arg5);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        callback(arg0, arg1, arg2, arg3, arg4, arg5);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    ret_t ret;
                    // No extra storage because this is a return, not a call
                    global_unserialize(p, NULL, &ret);
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    ret_t ret = m->ret;
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, arg5);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(arg3);
             size += global_ser_size(arg4);
             size += global_ser_size(arg5);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, ret);
        }
        int ser_size() {
             return global_ser_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        arg5_t arg5;
        global_unserialize(p, &extra_storage, &arg5);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        rm.ret = callback(arg0, arg1, arg2, arg3, arg4, arg5);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) {
            message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {
                throw rpc_peer_killed_exc_t();
            } catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, arg5);
            global_serialize(p, arg6);
        }
        int ser_size() {
             int size = 0;
            size += global_ser_size(arg0);
            size += global_ser_size(arg1);
            size += global_ser_size(arg2);
            size += global_ser_size(arg3);
            size += global_ser_size(arg4);
            size += global_ser_size(arg5);
            size += global_ser_size(arg6);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        arg5_t arg5;
        global_unserialize(p, &extra_storage, &arg5);
        arg6_t arg6;
        global_unserialize(p, &extra_storage, &arg6);
        p->done();
        callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
        // Args become invalid here because extra_storage dies
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        arg3_t arg3(m->arg3);
        arg4_t arg4(m->arg4);
        arg5_t arg5(m->arg5);
        arg6_t arg6(m->arg6);
        callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<bool>, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
                void run(cluster_message_t *msg) {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, arg5);
            global_serialize(p, arg6);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(arg3);
             size += global_ser_size(arg4);
             size += global_ser_size(arg5);
             size += global_ser_size(arg6);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        arg5_t arg5;
        global_unserialize(p, &extra_storage, &arg5);
        arg6_t arg6;
        global_unserialize(p, &extra_storage, &arg6);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    ret_t ret;
                    // No extra storage because this is a return, not a call
                    global_unserialize(p, NULL, &ret);
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    ret_t ret = m->ret;
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, arg5);
            global_serialize(p, arg6);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(arg3);
             size += global_ser_size(arg4);
             size += global_ser_size(arg5);
             size += global_ser_size(arg6);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, ret);
        }
        int ser_size() {
             return global_ser_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        arg5_t arg5;
        global_unserialize(p, &extra_storage, &arg5);
        arg6_t arg6;
        global_unserialize(p, &extra_storage, &arg6);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        rm.ret = callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) {
            message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {
                throw rpc_peer_killed_exc_t();
            } catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6), arg7(arg7) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        const arg7_t &arg7;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, arg5);
            global_serialize(p, arg6);
            global_serialize(p, arg7);
        }
        int ser_size() {
             int size = 0;
            size += global_ser_size(arg0);
            size += global_ser_size(arg1);
            size += global_ser_size(arg2);
            size += global_ser_size(arg3);
            size += global_ser_size(arg4);
            size += global_ser_size(arg5);
            size += global_ser_size(arg6);
            size += global_ser_size(arg7);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        arg5_t arg5;
        global_unserialize(p, &extra_storage, &arg5);
        arg6_t arg6;
        global_unserialize(p, &extra_storage, &arg6);
        arg7_t arg7;
        global_unserialize(p, &extra_storage, &arg7);
        p->done();
        callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        // Args become invalid here because extra_storage dies
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        arg3_t arg3(m->arg3);
        arg4_t arg4(m->arg4);
        arg5_t arg5(m->arg5);
        arg6_t arg6(m->arg6);
        arg7_t arg7(m->arg7);
        callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<bool>, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
                void run(cluster_message_t *msg) {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6), arg7(arg7) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        const arg7_t &arg7;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, arg5);
            global_serialize(p, arg6);
            global_serialize(p, arg7);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(arg3);
             size += global_ser_size(arg4);
             size += global_ser_size(arg5);
             size += global_ser_size(arg6);
             size += global_ser_size(arg7);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        arg5_t arg5;
        global_unserialize(p, &extra_storage, &arg5);
        arg6_t arg6;
        global_unserialize(p, &extra_storage, &arg6);
        arg7_t arg7;
        global_unserialize(p, &extra_storage, &arg7);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    ret_t ret;
                    // No extra storage because this is a return, not a call
                    global_unserialize(p, NULL, &ret);
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    ret_t ret = m->ret;
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6), arg7(arg7) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        const arg7_t &arg7;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, arg5);
            global_serialize(p, arg6);
            global_serialize(p, arg7);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(arg3);
             size += global_ser_size(arg4);
             size += global_ser_size(arg5);
             size += global_ser_size(arg6);
             size += global_ser_size(arg7);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, ret);
        }
        int ser_size() {
             return global_ser_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        arg5_t arg5;
        global_unserialize(p, &extra_storage, &arg5);
        arg6_t arg6;
        global_unserialize(p, &extra_storage, &arg6);
        arg7_t arg7;
        global_unserialize(p, &extra_storage, &arg7);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        rm.ret = callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t, class arg8_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) {
            message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {
                throw rpc_peer_killed_exc_t();
            } catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6), arg7(arg7), arg8(arg8) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        const arg7_t &arg7;
        const arg8_t &arg8;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, arg5);
            global_serialize(p, arg6);
            global_serialize(p, arg7);
            global_serialize(p, arg8);
        }
        int ser_size() {
             int size = 0;
            size += global_ser_size(arg0);
            size += global_ser_size(arg1);
            size += global_ser_size(arg2);
            size += global_ser_size(arg3);
            size += global_ser_size(arg4);
            size += global_ser_size(arg5);
            size += global_ser_size(arg6);
            size += global_ser_size(arg7);
            size += global_ser_size(arg8);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        arg5_t arg5;
        global_unserialize(p, &extra_storage, &arg5);
        arg6_t arg6;
        global_unserialize(p, &extra_storage, &arg6);
        arg7_t arg7;
        global_unserialize(p, &extra_storage, &arg7);
        arg8_t arg8;
        global_unserialize(p, &extra_storage, &arg8);
        p->done();
        callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        // Args become invalid here because extra_storage dies
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        arg3_t arg3(m->arg3);
        arg4_t arg4(m->arg4);
        arg5_t arg5(m->arg5);
        arg6_t arg6(m->arg6);
        arg7_t arg7(m->arg7);
        arg8_t arg8(m->arg8);
        callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t, class arg8_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<bool>, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
                void run(cluster_message_t *msg) {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6), arg7(arg7), arg8(arg8) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        const arg7_t &arg7;
        const arg8_t &arg8;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, arg5);
            global_serialize(p, arg6);
            global_serialize(p, arg7);
            global_serialize(p, arg8);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(arg3);
             size += global_ser_size(arg4);
             size += global_ser_size(arg5);
             size += global_ser_size(arg6);
             size += global_ser_size(arg7);
             size += global_ser_size(arg8);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        arg5_t arg5;
        global_unserialize(p, &extra_storage, &arg5);
        arg6_t arg6;
        global_unserialize(p, &extra_storage, &arg6);
        arg7_t arg7;
        global_unserialize(p, &extra_storage, &arg7);
        arg8_t arg8;
        global_unserialize(p, &extra_storage, &arg8);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7, m->arg8);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t, class arg8_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            struct reply_listener_t : public cluster_mailbox_t, public home_thread_mixin_t,
                     public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
            private:
                bool pulsed; //Truly annoying that we need to keep track of this
            public:
                reply_listener_t() : pulsed(false) {}
                void unserialize(cluster_inpipe_t *p) {
                    ret_t ret;
                    // No extra storage because this is a return, not a call
                    global_unserialize(p, NULL, &ret);
                    p->done();
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    ret_t ret = m->ret;
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(true, ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    on_thread_t syncer(home_thread);
                    if (pulsed) return;
                    else pulsed = true;
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            try { addr.send(&m); }
            catch (tcp_conn_t::write_closed_exc_t) {} //This means that the peer was killed but to avoid problems we need to let the reply_listener get pulsed and return the error there.
            catch (cluster_peer_t::write_peer_killed_exc_t) {
                throw rpc_peer_killed_exc_t();
            }
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        RDB_MAKE_ME_SERIALIZABLE_1(addr)
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6), arg7(arg7), arg8(arg8) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        const arg7_t &arg7;
        const arg8_t &arg8;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, arg0);
            global_serialize(p, arg1);
            global_serialize(p, arg2);
            global_serialize(p, arg3);
            global_serialize(p, arg4);
            global_serialize(p, arg5);
            global_serialize(p, arg6);
            global_serialize(p, arg7);
            global_serialize(p, arg8);
            global_serialize(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += global_ser_size(arg0);
             size += global_ser_size(arg1);
             size += global_ser_size(arg2);
             size += global_ser_size(arg3);
             size += global_ser_size(arg4);
             size += global_ser_size(arg5);
             size += global_ser_size(arg6);
             size += global_ser_size(arg7);
             size += global_ser_size(arg8);
             size += global_ser_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            global_serialize(p, ret);
        }
        int ser_size() {
             return global_ser_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) > callback;

    void unserialize(cluster_inpipe_t *p) {
        unserialize_extra_storage_t extra_storage;
        arg0_t arg0;
        global_unserialize(p, &extra_storage, &arg0);
        arg1_t arg1;
        global_unserialize(p, &extra_storage, &arg1);
        arg2_t arg2;
        global_unserialize(p, &extra_storage, &arg2);
        arg3_t arg3;
        global_unserialize(p, &extra_storage, &arg3);
        arg4_t arg4;
        global_unserialize(p, &extra_storage, &arg4);
        arg5_t arg5;
        global_unserialize(p, &extra_storage, &arg5);
        arg6_t arg6;
        global_unserialize(p, &extra_storage, &arg6);
        arg7_t arg7;
        global_unserialize(p, &extra_storage, &arg7);
        arg8_t arg8;
        global_unserialize(p, &extra_storage, &arg8);
        cluster_address_t reply_addr;
        global_unserialize(p, &extra_storage, &reply_addr);
        p->done();
        ret_message_t rm;
        rm.ret = callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
        try { reply_addr.send(&rm); }
        catch (tcp_conn_t::write_closed_exc_t) {}
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7, m->arg8);
        m->reply_to.send(&rm);
    }
};


#endif /* __RPC_RPC_HPP__ */

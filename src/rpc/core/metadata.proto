package metadata;

message Metadata {

    // We can hopefully use a templatized metadata map implementation, together
    // with a templatized "reader" that creates such a map object from a protobuffer
    // message.
    // For it to work, we require a map to have fields members and defuncts.
    // Defuncts must have a field key, and members must have fields key and value.
    // We can also have a versioned_value_t template, which requires the data to
    // have a field value and an uint32 field named version.
    // The template type that is used for values in the map template must
    // implement constructive_semilattice_t, which versioned_value_t does.


    // This is the structure that's used to establish a UUID -> physical address
    // mapping and to determine which nodes are currently part of the cluster.
    // It's the only metadata structure that's used directly by the
    // connection-management layer of clustering
    message Population_md {
        message Address_map_md {
            message Address {
                required string host = 1;
                required int32 port = 2;
            }
            message Versioned_address {
                required Address value = 1;
                required uint32 version = 2;
            }
            message Member {
                required bytes key = 1;
                required Versioned_address value = 2;
            }
            message Defunct {
                required bytes key = 1;
            }
            repeated Member members = 1;
            repeated Defunct defuncts = 2;
        }
    
        required Address_map_md address_map = 1;
    }
    
    // TODO! Put other metadata here
}

message TableRef {
    optional string db_name = 1;
    required string table_name = 2;
};

message VarTermTuple {
    required string var = 1;
    required Term term = 2;
};

message Term {
    enum TermType {
        VAR = 0;
        LET = 1;
        CALL = 2;
        IF = 3;
        ERROR = 4;
        NUMBER = 5;
        STRING = 6;
        JSON = 7;
        BOOL = 8;
        JSON_NULL = 9; //can't use just "NULL" here we get in trouble
        ARRAY = 10;
        OBJECT = 11;
        GETBYKEY = 12;
        TABLE = 13;
    };

    required TermType type = 1;

    optional string var = 2;

    message Let {
        repeated VarTermTuple binds = 1;
        required Term expr = 2;
    };

    optional Let let = 3;

    message Call {
        required Builtin builtin = 1;
        repeated Term args = 2;
    };

    optional Call call = 4;

    message If {
        required Term test = 1;
        required Term true_branch = 2;
        required Term false_branch = 3;
    };

    optional If if_ = 5;

    optional string error = 6;

    optional double number = 7;

    optional string valuestring = 8;

    optional string jsonstring = 9;

    optional bool valuebool = 10;

    repeated Term array = 11;

    repeated VarTermTuple object = 12;
    message GetByKey {
        required TableRef table_ref = 1;
        required string attrname = 2;
        required Term key = 3;
    };

    optional GetByKey get_by_key = 14;

    message Table {
        required TableRef table_ref = 1;
    };

    optional Table table = 15;
};

message Builtin {
    enum BuiltinType {
        NOT = 1;
        GETATTR = 2;
        HASATTR = 3;
        PICKATTRS = 4;
        MAPMERGE = 5;
        ARRAYAPPEND = 6;
        ARRAYCONCAT = 7;
        ARRAYSLICE = 8;
        ARRAYNTH  = 9;
        ARRAYLENGTH = 10;
        ADD = 11;
        SUBTRACT = 12;
        MULTIPLY = 13;
        DIVIDE = 14;
        MODULO = 15;
        COMPARE = 16;
        FILTER = 17;
        MAP = 18;          // operates over streams
        CONCATMAP = 19;
        ORDERBY = 20;
        DISTINCT = 21;
        LIMIT = 22;
        LENGTH = 23;
        UNION = 24;
        NTH = 25;
        STREAMTOARRAY = 26;
        ARRAYTOSTREAM = 27;
        REDUCE = 28;
        GROUPBY = 29;
        JAVASCRIPT = 30;
        JAVASCRIPTRETURNINGSTREAM = 31;
        ANY = 32;
        ALL = 33;
        RANGE = 34;
    };

    enum Comparison {
        EQ = 1;
        NE = 2;
        LT = 3;
        LE = 4;
        GT = 5;
        GE = 6;
    };

    required BuiltinType type = 1;

    optional string attr = 2; //used if type is GETATTR of HASATTR

    repeated string attrs = 3; //used if type is PICKATTRS

    optional Comparison comparison = 4;

    message Filter {
        required Predicate predicate = 1;
    };

    optional Filter filter = 5;

    message Map {
        required Mapping mapping = 1;
    };

    optional Map map = 6;

    message ConcatMap {
        required Mapping mapping = 1;
    };

    optional ConcatMap concat_map = 7;

    message OrderBy {
        required OrderDirection order_direction = 1;
        required Mapping mapping = 2;
    };

    optional OrderBy order_by = 8;

    optional Reduction reduce = 9;

    message GroupBy {
        required Mapping group_mapping = 1;
        required Mapping stream_to_json = 2;
    };

    optional GroupBy group_by = 10;

    message Range {
        required string attrname = 1;
        optional Term lowerbound = 2;
        optional Term upperbound = 3;
    };

    optional Range range = 11;
};

message Reduction {
    required Term base = 1;
    required string var1 = 2;
    required string var2 = 3;
    required Term body = 4;
};

message Mapping {
    required string arg = 1;
    required Term body = 2;
};

message Predicate {
    required string arg = 1;
    required Term body = 2;
};

enum OrderDirection {
    ASCENDING = 1;
    DESCENDING = 2;
}

message ReadQuery {
    required Term term = 1;
};

message WriteQuery {
    enum WriteQueryType {
        UPDATE = 1;
        DELETE = 2;
        MUTATE = 3;
        INSERT = 4;
        INSERTSTREAM = 5;
        FOREACH = 6;
        POINTUPDATE = 7;
        POINTDELETE = 8;
        POINTMUTATE = 9;
    };

    required WriteQueryType type = 1;

    message Update {
        required Term view = 1;
        required Mapping mapping = 2;
    };

    optional Update update = 2;

    message Delete {
        required Term view = 1;
    };

    optional Delete delete = 3;

    message Mutate {
        required Term view = 1;
        required Mapping mapping = 2;
    };

    optional Mutate mutate = 4;

    message Insert {
        required TableRef table_ref = 1;
        repeated Term terms = 2;
    };

    optional Insert insert = 5;

    message InsertStream {
        required TableRef table_ref = 1;
        required Term stream = 2;
    };

    optional InsertStream insert_stream = 6;

    message ForEach {
        required Term stream = 1;
        required string var = 2;
        repeated WriteQuery queries = 3;
    };

    optional ForEach for_each = 7;

    message PointUpdate {
        required TableRef table_ref = 1;
        required string attrname = 2;
        required Term key = 3;
        required Mapping mapping = 4;
    };

    optional PointUpdate point_update = 8;

    message PointDelete {
        required TableRef table_ref = 1;
        required string attrname = 2;
        required Term key = 3;
    };

    optional PointDelete point_delete = 9;

    message PointMutate {
        required TableRef table_ref = 1;
        required string attrname = 2;
        required Term key = 3;
        required Mapping mapping = 4;
    };

    optional PointMutate point_mutate = 10;
};

message Query {
    enum QueryType {
        READ = 1;
        WRITE = 2;
    }

    required QueryType type = 1;

    required int64 token = 2;

    optional ReadQuery read_query = 3;
    optional WriteQuery write_query = 4;
}

message Response {
    required int32 status_code = 1;

    required int64 token = 2;

    repeated string response = 3;
}

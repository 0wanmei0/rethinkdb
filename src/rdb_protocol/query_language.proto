message TableRef {
    optional string db_name = 1;
    required string table_name = 2;
};

message VarTermTuple {
    required Term var = 1;
    required Term term = 2;
};

message Term {
    enum TermType {
        VAR = 0;
        LET = 1;
        CALL = 2;
        IF = 3;
        TRY = 4;
        ERROR = 5;
        NUMBER = 6;
        STRING = 7;
        BOOL = 8;
        JSON_NULL = 9; //can't use just "NULL" here we get in trouble
        ARRAY = 10;
        MAP = 11;
        VIEWASSTREAM = 12;
        GETBYKEY = 13;
    };
    required TermType type = 1;

    optional string var = 2;

    message Let {
        repeated VarTermTuple binds = 1;
        required Term expr = 2;
    };

    optional Let let = 3;

    message Call {
        required Builtin builtin = 1;
        repeated Term args = 2;
    };

    optional Call call = 4;

    message If {
        required Term test = 1;
        required Term true_branch = 2;
        required Term false_branch = 3;
    };

    optional If if_ = 5; //Underscore to avoid conflicting with c++ keyword

    message Try {
        required Term try_term = 1;
        required VarTermTuple var_and_catch_term = 2;
    };

    optional Try try_ = 6; //Underscore to avoic conflicting with c++ keyword

    optional string error = 7;

    optional double number = 8;

    optional string valuestring = 9;

    optional bool valuebool = 10;

    repeated Term array = 11;

    repeated VarTermTuple map = 12;

    optional View view_as_stream = 13;

    message GetByKey {
        required TableRef table_ref = 1;
        required string attrname = 2;
        required Term value = 3; 
    };

    optional GetByKey get_by_key = 14;
};

message Builtin {
    enum BuiltinType {
        NOT = 1;
        GETATTR = 2;
        HASATTR = 3;
        PICKATTRS = 4;
        MAPMERGE = 5;
        ARRAYCONS = 6;
        ARRAYCONCAT = 7;
        ARRAYSLICE = 8;
        ARRAYNTH  = 9;
        ARRAYLENGTH = 10;
        ADD = 11;
        SUBTRACT = 12;
        MULTIPLY = 13;
        DIVIDE = 14;
        MODULO = 15;
        COMPARE = 16;
        FILTER = 17;
        MAP = 18;
        CONCATMAP = 19;
        ORDERBY = 20;
        DISTINCT = 21;
        LIMIT = 22;
        LENGTH = 23;
        UNION = 24;
        NTH = 25;
        STREAMTOARRAY = 26;
        ARRAYTOSTREAM = 27;
        REDUCE = 28;
        GROUPEDMAPREDUCE = 29;
        JAVASCRIPT = 30;
        JAVASCRIPTRETURNINGSTREAM = 31;
        MAPREDUCE = 32;
    };

    required BuiltinType type = 1;

    optional string attr = 2; //used if type is GETATTR of HASATTR

    repeated string attrs = 3; //used if type is PICKATTRS

    message Filter {
        required Predicate predicate = 1;
    };

    optional Filter filter = 4;

    message Map {
        required Mapping mapping = 1;
    };

    optional Map map = 5;

    message ConcatMap {
        required Mapping mapping = 1;
    };

    optional ConcatMap concat_map = 6;

    message OrderBy {
        required OrderDirection order_direction = 1;
        required Mapping mapping = 2;
    };

    optional OrderBy order_by = 7;

    message Distinct {
        required Mapping mapping = 1;
    };

    optional Distinct distinct = 8;

    message Limit {
        required  int32 limit = 1;
    }

    optional Limit limit = 9;

    message Reduce {
        required Reduction reduction = 1;
    };

    optional Reduce reduce = 10;

    message GroupedMapReduce {
        required Mapping group_mapping = 1;
        required MapReduce map_reduce = 2;
    };

    optional GroupedMapReduce grouped_map_reduce = 11;

    message MapReduce {
        required Mapping change_mapping = 1;
        required Reduction reduction = 2;
    };

    optional MapReduce map_reduce = 12;
};

enum Comparison {
    EQ = 1;
    NE = 2;
    LT = 3;
    LE = 4;
    GT = 5;
    GE = 6;
}

message Reduction {
    required Term base = 1;
    required Term var1 = 2;
    required Term var2 = 3;
    required Term body = 4;
};

message Mapping {
    required Term arg = 1;
    required Term body = 2;
};

message Predicate {
    required Term arg = 1;
    required Term body = 2;
};

message View {
    enum ViewType {
        TABLE = 1;
        FILTERVIEW = 2;
        RANGEVIEW = 3;
    };

    required ViewType type = 1;

    message Table {
        required TableRef table_ref = 1;
    };

    optional Table table = 2;

    message FilterView {
        required View view = 1;
        required Predicate predicate = 2;
    };

    optional FilterView filter_view = 3;

    message RangeView {
        required View view = 1;
        required string attrname = 2;
        optional Term lowerbound = 3;
        optional Term upperbound = 4;
    };

    optional RangeView range_view = 4;
};

enum OrderDirection {
    ASCENDING = 1;
    DESCENDING = 2;
}

message ReadQuery {
    required Term term = 1;
};

message WriteQuery {
    enum WriteQueryType {
        UPDATE = 1;
        DELETE = 2;
        MUTATE = 3;
        INSERT = 4;
        INSERTSTREAM = 5;
        FOREACH = 6;
        POINTUPDATE = 7;
        POINTDELETE = 8;
        POINTMUTATE = 9;
    };

    required WriteQueryType type = 1;

    message Update {
        required View view = 1;
        required Mapping mapping = 2;
    };

    optional Update update = 2;

    message Delete {
        required View view = 1;
    };

    optional Delete delete_ = 3; //underscore to avoid conflicting with C++ keyword

    message Mutate {
        required View view = 1;
        required Mapping mapping = 2;
    };

    optional Mutate mutate = 4;

    message Insert {
        required TableRef table_ref = 1;
        repeated Term terms = 2;
    };

    optional Insert insert = 5;

    message InsertStream {
        required TableRef table_ref = 1;
        required Term stream = 2;
    };

    optional InsertStream insert_stream = 6;

    message ForEach {
        required Term stream = 1;
        required Term var = 2;
        repeated WriteQuery queries = 3;
    };

    optional ForEach for_each = 7;

    message PointUpdate {
        required TableRef table_ref = 1;
        required string attrname = 2;
        required Term key = 3;
        required Mapping mapping = 4;
    };

    optional PointUpdate point_update = 8;

    message PointDelete {
        required TableRef table_ref = 1;
        required string attrname = 2;
        required Term key = 3;
    };

    optional PointDelete point_delete = 9;

    message PointMutate {
        required TableRef table_ref = 1;
        required string attrname = 2;
        required Term key = 3;
    };

    optional PointMutate point_mutate = 10;
};

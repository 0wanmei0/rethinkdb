#ifndef __CLUSTERING_RPC_HPP__
#define __CLUSTERING_RPC_HPP__

/* This file is automatically generated by '../scripts/generate_rpc_templates.py'.
Please modify '../scripts/generate_rpc_templates.py' instead of modifying this file.*/

#include "clustering/serialize.hpp"
#include "concurrency/cond_var.hpp"

template<int format_id, class proto_t> class async_mailbox_t;
template<int format_id, class proto_t> class sync_mailbox_t;

template<int f_id>
class async_mailbox_t< f_id, void() > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void() > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call() {
            unique_ptr_t<message_t> m(new message_t);
            addr.send(m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
    };
    unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
        unique_ptr_t<message_t> mp(new message_t);
        return mp;
    }

    boost::function< void() > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<message_t> m(static_pointer_cast<message_t>(cm));
        callback();
    }
};

template<int f_id>
class sync_mailbox_t< f_id, void() > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void() > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call() {
            unique_ptr_t<call_message_t> m(new call_message_t);
            struct : public cluster_mailbox_t, public cond_t {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    pulse();
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
    };

    boost::function< void() > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        callback();
        m.reply_to.send(m2);
    }
};

template<int f_id, class ret_t>
class sync_mailbox_t< f_id, ret_t() > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t() > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call() {
            unique_ptr_t<call_message_t> m(new call_message_t);
            struct : public cluster_mailbox_t, public promise_t<ret_t> {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    ::unserialize(p, &m->ret);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    unique_ptr_t<ret_message_t> m(static_pointer_cast<ret_message_t>(m));
                    pulse(m->ret);
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            return reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
    };

    boost::function< ret_t() > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        m2.ret = callback();
        m.reply_to.send(m2);
    }
};

template<int f_id, class arg0_t>
class async_mailbox_t< f_id, void(arg0_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(arg0_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0) {
            unique_ptr_t<message_t> m(new message_t);
            m->arg0 = arg0;
            addr.send(m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        arg0_t arg0;
        void serialize(cluster_outpipe_t *p) {
            ::serialize(p, &arg0);
        }
    };
    unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
        unique_ptr_t<message_t> mp(new message_t);
        ::unserialize(p, &mp->arg0);
        return mp;
    }

    boost::function< void(arg0_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<message_t> m(static_pointer_cast<message_t>(cm));
        callback(m->arg0);
    }
};

template<int f_id, class arg0_t>
class sync_mailbox_t< f_id, void(arg0_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(arg0_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            struct : public cluster_mailbox_t, public cond_t {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    pulse();
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
    };

    boost::function< void(arg0_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        callback(m->arg0);
        m.reply_to.send(m2);
    }
};

template<int f_id, class ret_t, class arg0_t>
class sync_mailbox_t< f_id, ret_t(arg0_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(arg0_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            struct : public cluster_mailbox_t, public promise_t<ret_t> {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    ::unserialize(p, &m->ret);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    unique_ptr_t<ret_message_t> m(static_pointer_cast<ret_message_t>(m));
                    pulse(m->ret);
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            return reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
    };

    boost::function< ret_t(arg0_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        m2.ret = callback(m->arg0);
        m.reply_to.send(m2);
    }
};

template<int f_id, class arg0_t, class arg1_t>
class async_mailbox_t< f_id, void(arg0_t, arg1_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(arg0_t, arg1_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1) {
            unique_ptr_t<message_t> m(new message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            addr.send(m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        void serialize(cluster_outpipe_t *p) {
            ::serialize(p, &arg0);
            ::serialize(p, &arg1);
        }
    };
    unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
        unique_ptr_t<message_t> mp(new message_t);
        ::unserialize(p, &mp->arg0);
        ::unserialize(p, &mp->arg1);
        return mp;
    }

    boost::function< void(arg0_t, arg1_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<message_t> m(static_pointer_cast<message_t>(cm));
        callback(m->arg0, m->arg1);
    }
};

template<int f_id, class arg0_t, class arg1_t>
class sync_mailbox_t< f_id, void(arg0_t, arg1_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(arg0_t, arg1_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            struct : public cluster_mailbox_t, public cond_t {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    pulse();
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
    };

    boost::function< void(arg0_t, arg1_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        callback(m->arg0, m->arg1);
        m.reply_to.send(m2);
    }
};

template<int f_id, class ret_t, class arg0_t, class arg1_t>
class sync_mailbox_t< f_id, ret_t(arg0_t, arg1_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(arg0_t, arg1_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            struct : public cluster_mailbox_t, public promise_t<ret_t> {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    ::unserialize(p, &m->ret);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    unique_ptr_t<ret_message_t> m(static_pointer_cast<ret_message_t>(m));
                    pulse(m->ret);
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            return reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
    };

    boost::function< ret_t(arg0_t, arg1_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        m2.ret = callback(m->arg0, m->arg1);
        m.reply_to.send(m2);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t>
class async_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) {
            unique_ptr_t<message_t> m(new message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            addr.send(m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        void serialize(cluster_outpipe_t *p) {
            ::serialize(p, &arg0);
            ::serialize(p, &arg1);
            ::serialize(p, &arg2);
        }
    };
    unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
        unique_ptr_t<message_t> mp(new message_t);
        ::unserialize(p, &mp->arg0);
        ::unserialize(p, &mp->arg1);
        ::unserialize(p, &mp->arg2);
        return mp;
    }

    boost::function< void(arg0_t, arg1_t, arg2_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<message_t> m(static_pointer_cast<message_t>(cm));
        callback(m->arg0, m->arg1, m->arg2);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t>
class sync_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            struct : public cluster_mailbox_t, public cond_t {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    pulse();
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
    };

    boost::function< void(arg0_t, arg1_t, arg2_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        callback(m->arg0, m->arg1, m->arg2);
        m.reply_to.send(m2);
    }
};

template<int f_id, class ret_t, class arg0_t, class arg1_t, class arg2_t>
class sync_mailbox_t< f_id, ret_t(arg0_t, arg1_t, arg2_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(arg0_t, arg1_t, arg2_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            struct : public cluster_mailbox_t, public promise_t<ret_t> {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    ::unserialize(p, &m->ret);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    unique_ptr_t<ret_message_t> m(static_pointer_cast<ret_message_t>(m));
                    pulse(m->ret);
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            return reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
    };

    boost::function< ret_t(arg0_t, arg1_t, arg2_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        m2.ret = callback(m->arg0, m->arg1, m->arg2);
        m.reply_to.send(m2);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t, class arg3_t>
class async_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t, arg3_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) {
            unique_ptr_t<message_t> m(new message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            addr.send(m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        void serialize(cluster_outpipe_t *p) {
            ::serialize(p, &arg0);
            ::serialize(p, &arg1);
            ::serialize(p, &arg2);
            ::serialize(p, &arg3);
        }
    };
    unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
        unique_ptr_t<message_t> mp(new message_t);
        ::unserialize(p, &mp->arg0);
        ::unserialize(p, &mp->arg1);
        ::unserialize(p, &mp->arg2);
        ::unserialize(p, &mp->arg3);
        return mp;
    }

    boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<message_t> m(static_pointer_cast<message_t>(cm));
        callback(m->arg0, m->arg1, m->arg2, m->arg3);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t, class arg3_t>
class sync_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t, arg3_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            struct : public cluster_mailbox_t, public cond_t {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    pulse();
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
    };

    boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        callback(m->arg0, m->arg1, m->arg2, m->arg3);
        m.reply_to.send(m2);
    }
};

template<int f_id, class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t>
class sync_mailbox_t< f_id, ret_t(arg0_t, arg1_t, arg2_t, arg3_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(arg0_t, arg1_t, arg2_t, arg3_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            struct : public cluster_mailbox_t, public promise_t<ret_t> {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    ::unserialize(p, &m->ret);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    unique_ptr_t<ret_message_t> m(static_pointer_cast<ret_message_t>(m));
                    pulse(m->ret);
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            return reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
    };

    boost::function< ret_t(arg0_t, arg1_t, arg2_t, arg3_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        m2.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3);
        m.reply_to.send(m2);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t>
class async_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) {
            unique_ptr_t<message_t> m(new message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            addr.send(m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        void serialize(cluster_outpipe_t *p) {
            ::serialize(p, &arg0);
            ::serialize(p, &arg1);
            ::serialize(p, &arg2);
            ::serialize(p, &arg3);
            ::serialize(p, &arg4);
        }
    };
    unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
        unique_ptr_t<message_t> mp(new message_t);
        ::unserialize(p, &mp->arg0);
        ::unserialize(p, &mp->arg1);
        ::unserialize(p, &mp->arg2);
        ::unserialize(p, &mp->arg3);
        ::unserialize(p, &mp->arg4);
        return mp;
    }

    boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<message_t> m(static_pointer_cast<message_t>(cm));
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t>
class sync_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            struct : public cluster_mailbox_t, public cond_t {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    pulse();
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
    };

    boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4);
        m.reply_to.send(m2);
    }
};

template<int f_id, class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t>
class sync_mailbox_t< f_id, ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            struct : public cluster_mailbox_t, public promise_t<ret_t> {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    ::unserialize(p, &m->ret);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    unique_ptr_t<ret_message_t> m(static_pointer_cast<ret_message_t>(m));
                    pulse(m->ret);
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            return reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
    };

    boost::function< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        m2.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4);
        m.reply_to.send(m2);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t>
class async_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) {
            unique_ptr_t<message_t> m(new message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            m->arg5 = arg5;
            addr.send(m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        arg5_t arg5;
        void serialize(cluster_outpipe_t *p) {
            ::serialize(p, &arg0);
            ::serialize(p, &arg1);
            ::serialize(p, &arg2);
            ::serialize(p, &arg3);
            ::serialize(p, &arg4);
            ::serialize(p, &arg5);
        }
    };
    unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
        unique_ptr_t<message_t> mp(new message_t);
        ::unserialize(p, &mp->arg0);
        ::unserialize(p, &mp->arg1);
        ::unserialize(p, &mp->arg2);
        ::unserialize(p, &mp->arg3);
        ::unserialize(p, &mp->arg4);
        ::unserialize(p, &mp->arg5);
        return mp;
    }

    boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<message_t> m(static_pointer_cast<message_t>(cm));
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t>
class sync_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            m->arg5 = arg5;
            struct : public cluster_mailbox_t, public cond_t {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    pulse();
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        arg5_t arg5;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
    };

    boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5);
        m.reply_to.send(m2);
    }
};

template<int f_id, class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t>
class sync_mailbox_t< f_id, ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            m->arg5 = arg5;
            struct : public cluster_mailbox_t, public promise_t<ret_t> {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    ::unserialize(p, &m->ret);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    unique_ptr_t<ret_message_t> m(static_pointer_cast<ret_message_t>(m));
                    pulse(m->ret);
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            return reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        arg5_t arg5;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
    };

    boost::function< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        m2.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5);
        m.reply_to.send(m2);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t>
class async_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) {
            unique_ptr_t<message_t> m(new message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            m->arg5 = arg5;
            m->arg6 = arg6;
            addr.send(m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        arg5_t arg5;
        arg6_t arg6;
        void serialize(cluster_outpipe_t *p) {
            ::serialize(p, &arg0);
            ::serialize(p, &arg1);
            ::serialize(p, &arg2);
            ::serialize(p, &arg3);
            ::serialize(p, &arg4);
            ::serialize(p, &arg5);
            ::serialize(p, &arg6);
        }
    };
    unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
        unique_ptr_t<message_t> mp(new message_t);
        ::unserialize(p, &mp->arg0);
        ::unserialize(p, &mp->arg1);
        ::unserialize(p, &mp->arg2);
        ::unserialize(p, &mp->arg3);
        ::unserialize(p, &mp->arg4);
        ::unserialize(p, &mp->arg5);
        ::unserialize(p, &mp->arg6);
        return mp;
    }

    boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<message_t> m(static_pointer_cast<message_t>(cm));
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t>
class sync_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            m->arg5 = arg5;
            m->arg6 = arg6;
            struct : public cluster_mailbox_t, public cond_t {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    pulse();
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        arg5_t arg5;
        arg6_t arg6;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
    };

    boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6);
        m.reply_to.send(m2);
    }
};

template<int f_id, class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t>
class sync_mailbox_t< f_id, ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            m->arg5 = arg5;
            m->arg6 = arg6;
            struct : public cluster_mailbox_t, public promise_t<ret_t> {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    ::unserialize(p, &m->ret);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    unique_ptr_t<ret_message_t> m(static_pointer_cast<ret_message_t>(m));
                    pulse(m->ret);
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            return reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        arg5_t arg5;
        arg6_t arg6;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
    };

    boost::function< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        m2.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6);
        m.reply_to.send(m2);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t>
class async_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) {
            unique_ptr_t<message_t> m(new message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            m->arg5 = arg5;
            m->arg6 = arg6;
            m->arg7 = arg7;
            addr.send(m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        arg5_t arg5;
        arg6_t arg6;
        arg7_t arg7;
        void serialize(cluster_outpipe_t *p) {
            ::serialize(p, &arg0);
            ::serialize(p, &arg1);
            ::serialize(p, &arg2);
            ::serialize(p, &arg3);
            ::serialize(p, &arg4);
            ::serialize(p, &arg5);
            ::serialize(p, &arg6);
            ::serialize(p, &arg7);
        }
    };
    unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
        unique_ptr_t<message_t> mp(new message_t);
        ::unserialize(p, &mp->arg0);
        ::unserialize(p, &mp->arg1);
        ::unserialize(p, &mp->arg2);
        ::unserialize(p, &mp->arg3);
        ::unserialize(p, &mp->arg4);
        ::unserialize(p, &mp->arg5);
        ::unserialize(p, &mp->arg6);
        ::unserialize(p, &mp->arg7);
        return mp;
    }

    boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<message_t> m(static_pointer_cast<message_t>(cm));
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t>
class sync_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            m->arg5 = arg5;
            m->arg6 = arg6;
            m->arg7 = arg7;
            struct : public cluster_mailbox_t, public cond_t {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    pulse();
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        arg5_t arg5;
        arg6_t arg6;
        arg7_t arg7;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
    };

    boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7);
        m.reply_to.send(m2);
    }
};

template<int f_id, class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t>
class sync_mailbox_t< f_id, ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            m->arg5 = arg5;
            m->arg6 = arg6;
            m->arg7 = arg7;
            struct : public cluster_mailbox_t, public promise_t<ret_t> {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    ::unserialize(p, &m->ret);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    unique_ptr_t<ret_message_t> m(static_pointer_cast<ret_message_t>(m));
                    pulse(m->ret);
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            return reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        arg5_t arg5;
        arg6_t arg6;
        arg7_t arg7;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
    };

    boost::function< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        m2.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7);
        m.reply_to.send(m2);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t, class arg8_t>
class async_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) {
            unique_ptr_t<message_t> m(new message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            m->arg5 = arg5;
            m->arg6 = arg6;
            m->arg7 = arg7;
            m->arg8 = arg8;
            addr.send(m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        arg5_t arg5;
        arg6_t arg6;
        arg7_t arg7;
        arg8_t arg8;
        void serialize(cluster_outpipe_t *p) {
            ::serialize(p, &arg0);
            ::serialize(p, &arg1);
            ::serialize(p, &arg2);
            ::serialize(p, &arg3);
            ::serialize(p, &arg4);
            ::serialize(p, &arg5);
            ::serialize(p, &arg6);
            ::serialize(p, &arg7);
            ::serialize(p, &arg8);
        }
    };
    unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
        unique_ptr_t<message_t> mp(new message_t);
        ::unserialize(p, &mp->arg0);
        ::unserialize(p, &mp->arg1);
        ::unserialize(p, &mp->arg2);
        ::unserialize(p, &mp->arg3);
        ::unserialize(p, &mp->arg4);
        ::unserialize(p, &mp->arg5);
        ::unserialize(p, &mp->arg6);
        ::unserialize(p, &mp->arg7);
        ::unserialize(p, &mp->arg8);
        return mp;
    }

    boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<message_t> m(static_pointer_cast<message_t>(cm));
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7, m->arg8);
    }
};

template<int f_id, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t, class arg8_t>
class sync_mailbox_t< f_id, void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            m->arg5 = arg5;
            m->arg6 = arg6;
            m->arg7 = arg7;
            m->arg8 = arg8;
            struct : public cluster_mailbox_t, public cond_t {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    pulse();
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        arg5_t arg5;
        arg6_t arg6;
        arg7_t arg7;
        arg8_t arg8;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
    };

    boost::function< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7, m->arg8);
        m.reply_to.send(m2);
    }
};

template<int f_id, class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t, class arg8_t>
class sync_mailbox_t< f_id, ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) {
            unique_ptr_t<call_message_t> m(new call_message_t);
            m->arg0 = arg0;
            m->arg1 = arg1;
            m->arg2 = arg2;
            m->arg3 = arg3;
            m->arg4 = arg4;
            m->arg5 = arg5;
            m->arg6 = arg6;
            m->arg7 = arg7;
            m->arg8 = arg8;
            struct : public cluster_mailbox_t, public promise_t<ret_t> {
                unique_ptr_t<cluster_message_t> unserialize(cluster_inpipe_t *p) {
                    unique_ptr_t<ret_message_t> m(new ret_message_t);
                    ::unserialize(p, &m->ret);
                    return m;
                }
                void run(unique_ptr_t<cluster_message_t> msg) {
                    unique_ptr_t<ret_message_t> m(static_pointer_cast<ret_message_t>(m));
                    pulse(m->ret);
                }
            } reply_listener;
            m->reply_to = &reply_listener;
            addr.send(m);
            return reply_listener.wait();
        }
        static void serialize(cluster_outpipe_t *p, const address_t *addr) {
            ::serialize(p, &addr->addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        arg0_t arg0;
        arg1_t arg1;
        arg2_t arg2;
        arg3_t arg3;
        arg4_t arg4;
        arg5_t arg5;
        arg6_t arg6;
        arg7_t arg7;
        arg8_t arg8;
        cluster_address_t reply_to;
    };

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
    };

    boost::function< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > callback;
    void run(unique_ptr_t<cluster_message_t> cm) {
        unique_ptr_t<call_message_t> m(static_pointer_cast<call_message_t>(cm));
        unique_ptr_t<ret_message_t> m2(new ret_message_t);
        m2.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7, m->arg8);
        m.reply_to.send(m2);
    }
};


#endif /* __CLUSTERING_RPC_HPP__ */

#ifndef __CLUSTERING_RPC_HPP__
#define __CLUSTERING_RPC_HPP__

/* This file is automatically generated by '../scripts/generate_rpc_templates.py'.
Please modify '../scripts/generate_rpc_templates.py' instead of modifying this file.*/

#include "clustering/serialize.hpp"
#include "concurrency/cond_var.hpp"
#include "clustering/cluster.hpp"
#include "clustering/peer.hpp"

template<class proto_t> class async_mailbox_t {
    // BOOST_STATIC_ASSERT(false);
};

template<class proto_t> class sync_mailbox_t;

struct rpc_peer_killed_exc_t : public std::exception {
    const char *what() throw () {
        return "Peer killed during rpc\n";
    }
};
template<>
class async_mailbox_t< void() > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void() > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call() {
            message_t m;
            addr.send(&m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t()
            { }
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             int size = 0;
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        p->done();
        callback();
    }

    boost::function< void() > callback;
    void run(cluster_message_t *cm) {
        callback();
    }
};

template<>
class sync_mailbox_t< void() > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void() > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call() {
            call_message_t m;
            struct : public cluster_mailbox_t, public promise_t<bool>, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    pulse(true);
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t()
            { }
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void() > callback;

    void unserialize(cluster_inpipe_t *p) {
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        callback();
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback();
        m->reply_to.send(&rm);
    }
};

template<class ret_t>
class sync_mailbox_t< ret_t() > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t() > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call() {
            call_message_t m;
            struct : public cluster_mailbox_t, public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    typename format_t<ret_t>::parser_t parser(p);
                    pulse(std::make_pair(true, parser.value()));
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    pulse(std::make_pair(true, m->ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t()
            { }
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            format_t<ret_t>::write(p, ret);
        }
        int ser_size() {
             return format_t<ret_t>::get_size(ret);
        }
    };

    boost::function< ret_t() > callback;

    void unserialize(cluster_inpipe_t *p) {
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        rm.ret = callback();
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback();
        m->reply_to.send(&rm);
    }
};

template<class arg0_t>
class async_mailbox_t< void(arg0_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0) {
            message_t m(arg0);
            addr.send(&m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0)
            : arg0(arg0) { }
        const arg0_t &arg0;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
        }
        int ser_size() {
             int size = 0;
            size += format_t<arg0_t>::get_size(arg0);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        p->done();
        callback(parser0.value());
    }

    boost::function< void(const arg0_t &arg0) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        callback(arg0);
    }
};

template<class arg0_t>
class sync_mailbox_t< void(arg0_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0) {
            call_message_t m(arg0);
            struct : public cluster_mailbox_t, public promise_t<bool>, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    pulse(true);
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0)
            : arg0(arg0) { }
        const arg0_t &arg0;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        callback(parser0.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t>
class sync_mailbox_t< ret_t(arg0_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0) {
            call_message_t m(arg0);
            struct : public cluster_mailbox_t, public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    typename format_t<ret_t>::parser_t parser(p);
                    pulse(std::make_pair(true, parser.value()));
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    pulse(std::make_pair(true, m->ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0)
            : arg0(arg0) { }
        const arg0_t &arg0;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            format_t<ret_t>::write(p, ret);
        }
        int ser_size() {
             return format_t<ret_t>::get_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        rm.ret = callback(parser0.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t>
class async_mailbox_t< void(arg0_t, arg1_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1) {
            message_t m(arg0, arg1);
            addr.send(&m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1)
            : arg0(arg0), arg1(arg1) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
        }
        int ser_size() {
             int size = 0;
            size += format_t<arg0_t>::get_size(arg0);
            size += format_t<arg1_t>::get_size(arg1);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        p->done();
        callback(parser0.value(), parser1.value());
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        callback(arg0, arg1);
    }
};

template<class arg0_t, class arg1_t>
class sync_mailbox_t< void(arg0_t, arg1_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1) {
            call_message_t m(arg0, arg1);
            struct : public cluster_mailbox_t, public promise_t<bool>, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    pulse(true);
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1)
            : arg0(arg0), arg1(arg1) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        callback(parser0.value(), parser1.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1) {
            call_message_t m(arg0, arg1);
            struct : public cluster_mailbox_t, public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    typename format_t<ret_t>::parser_t parser(p);
                    pulse(std::make_pair(true, parser.value()));
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    pulse(std::make_pair(true, m->ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1)
            : arg0(arg0), arg1(arg1) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            format_t<ret_t>::write(p, ret);
        }
        int ser_size() {
             return format_t<ret_t>::get_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        rm.ret = callback(parser0.value(), parser1.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) {
            message_t m(arg0, arg1, arg2);
            addr.send(&m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2)
            : arg0(arg0), arg1(arg1), arg2(arg2) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
        }
        int ser_size() {
             int size = 0;
            size += format_t<arg0_t>::get_size(arg0);
            size += format_t<arg1_t>::get_size(arg1);
            size += format_t<arg2_t>::get_size(arg2);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        p->done();
        callback(parser0.value(), parser1.value(), parser2.value());
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        callback(arg0, arg1, arg2);
    }
};

template<class arg0_t, class arg1_t, class arg2_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) {
            call_message_t m(arg0, arg1, arg2);
            struct : public cluster_mailbox_t, public promise_t<bool>, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    pulse(true);
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2)
            : arg0(arg0), arg1(arg1), arg2(arg2) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        callback(parser0.value(), parser1.value(), parser2.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) {
            call_message_t m(arg0, arg1, arg2);
            struct : public cluster_mailbox_t, public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    typename format_t<ret_t>::parser_t parser(p);
                    pulse(std::make_pair(true, parser.value()));
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    pulse(std::make_pair(true, m->ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2)
            : arg0(arg0), arg1(arg1), arg2(arg2) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            format_t<ret_t>::write(p, ret);
        }
        int ser_size() {
             return format_t<ret_t>::get_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        rm.ret = callback(parser0.value(), parser1.value(), parser2.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) {
            message_t m(arg0, arg1, arg2, arg3);
            addr.send(&m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
        }
        int ser_size() {
             int size = 0;
            size += format_t<arg0_t>::get_size(arg0);
            size += format_t<arg1_t>::get_size(arg1);
            size += format_t<arg2_t>::get_size(arg2);
            size += format_t<arg3_t>::get_size(arg3);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        p->done();
        callback(parser0.value(), parser1.value(), parser2.value(), parser3.value());
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        arg3_t arg3(m->arg3);
        callback(arg0, arg1, arg2, arg3);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) {
            call_message_t m(arg0, arg1, arg2, arg3);
            struct : public cluster_mailbox_t, public promise_t<bool>, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    pulse(true);
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<arg3_t>::get_size(arg3);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        callback(parser0.value(), parser1.value(), parser2.value(), parser3.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2, m->arg3);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t, arg3_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) {
            call_message_t m(arg0, arg1, arg2, arg3);
            struct : public cluster_mailbox_t, public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    typename format_t<ret_t>::parser_t parser(p);
                    pulse(std::make_pair(true, parser.value()));
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    pulse(std::make_pair(true, m->ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<arg3_t>::get_size(arg3);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            format_t<ret_t>::write(p, ret);
        }
        int ser_size() {
             return format_t<ret_t>::get_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        rm.ret = callback(parser0.value(), parser1.value(), parser2.value(), parser3.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) {
            message_t m(arg0, arg1, arg2, arg3, arg4);
            addr.send(&m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
        }
        int ser_size() {
             int size = 0;
            size += format_t<arg0_t>::get_size(arg0);
            size += format_t<arg1_t>::get_size(arg1);
            size += format_t<arg2_t>::get_size(arg2);
            size += format_t<arg3_t>::get_size(arg3);
            size += format_t<arg4_t>::get_size(arg4);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        p->done();
        callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value());
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        arg3_t arg3(m->arg3);
        arg4_t arg4(m->arg4);
        callback(arg0, arg1, arg2, arg3, arg4);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4);
            struct : public cluster_mailbox_t, public promise_t<bool>, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    pulse(true);
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<arg3_t>::get_size(arg3);
             size += format_t<arg4_t>::get_size(arg4);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4);
            struct : public cluster_mailbox_t, public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    typename format_t<ret_t>::parser_t parser(p);
                    pulse(std::make_pair(true, parser.value()));
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    pulse(std::make_pair(true, m->ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<arg3_t>::get_size(arg3);
             size += format_t<arg4_t>::get_size(arg4);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            format_t<ret_t>::write(p, ret);
        }
        int ser_size() {
             return format_t<ret_t>::get_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        rm.ret = callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) {
            message_t m(arg0, arg1, arg2, arg3, arg4, arg5);
            addr.send(&m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<arg5_t>::write(p, arg5);
        }
        int ser_size() {
             int size = 0;
            size += format_t<arg0_t>::get_size(arg0);
            size += format_t<arg1_t>::get_size(arg1);
            size += format_t<arg2_t>::get_size(arg2);
            size += format_t<arg3_t>::get_size(arg3);
            size += format_t<arg4_t>::get_size(arg4);
            size += format_t<arg5_t>::get_size(arg5);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        typename format_t<arg5_t>::parser_t parser5(p);
        p->done();
        callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value(), parser5.value());
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        arg3_t arg3(m->arg3);
        arg4_t arg4(m->arg4);
        arg5_t arg5(m->arg5);
        callback(arg0, arg1, arg2, arg3, arg4, arg5);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5);
            struct : public cluster_mailbox_t, public promise_t<bool>, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    pulse(true);
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<arg5_t>::write(p, arg5);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<arg3_t>::get_size(arg3);
             size += format_t<arg4_t>::get_size(arg4);
             size += format_t<arg5_t>::get_size(arg5);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        typename format_t<arg5_t>::parser_t parser5(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value(), parser5.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5);
            struct : public cluster_mailbox_t, public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    typename format_t<ret_t>::parser_t parser(p);
                    pulse(std::make_pair(true, parser.value()));
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    pulse(std::make_pair(true, m->ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<arg5_t>::write(p, arg5);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<arg3_t>::get_size(arg3);
             size += format_t<arg4_t>::get_size(arg4);
             size += format_t<arg5_t>::get_size(arg5);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            format_t<ret_t>::write(p, ret);
        }
        int ser_size() {
             return format_t<ret_t>::get_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        typename format_t<arg5_t>::parser_t parser5(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        rm.ret = callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value(), parser5.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) {
            message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            addr.send(&m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<arg5_t>::write(p, arg5);
            format_t<arg6_t>::write(p, arg6);
        }
        int ser_size() {
             int size = 0;
            size += format_t<arg0_t>::get_size(arg0);
            size += format_t<arg1_t>::get_size(arg1);
            size += format_t<arg2_t>::get_size(arg2);
            size += format_t<arg3_t>::get_size(arg3);
            size += format_t<arg4_t>::get_size(arg4);
            size += format_t<arg5_t>::get_size(arg5);
            size += format_t<arg6_t>::get_size(arg6);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        typename format_t<arg5_t>::parser_t parser5(p);
        typename format_t<arg6_t>::parser_t parser6(p);
        p->done();
        callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value(), parser5.value(), parser6.value());
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        arg3_t arg3(m->arg3);
        arg4_t arg4(m->arg4);
        arg5_t arg5(m->arg5);
        arg6_t arg6(m->arg6);
        callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            struct : public cluster_mailbox_t, public promise_t<bool>, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    pulse(true);
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<arg5_t>::write(p, arg5);
            format_t<arg6_t>::write(p, arg6);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<arg3_t>::get_size(arg3);
             size += format_t<arg4_t>::get_size(arg4);
             size += format_t<arg5_t>::get_size(arg5);
             size += format_t<arg6_t>::get_size(arg6);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        typename format_t<arg5_t>::parser_t parser5(p);
        typename format_t<arg6_t>::parser_t parser6(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value(), parser5.value(), parser6.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6);
            struct : public cluster_mailbox_t, public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    typename format_t<ret_t>::parser_t parser(p);
                    pulse(std::make_pair(true, parser.value()));
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    pulse(std::make_pair(true, m->ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<arg5_t>::write(p, arg5);
            format_t<arg6_t>::write(p, arg6);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<arg3_t>::get_size(arg3);
             size += format_t<arg4_t>::get_size(arg4);
             size += format_t<arg5_t>::get_size(arg5);
             size += format_t<arg6_t>::get_size(arg6);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            format_t<ret_t>::write(p, ret);
        }
        int ser_size() {
             return format_t<ret_t>::get_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        typename format_t<arg5_t>::parser_t parser5(p);
        typename format_t<arg6_t>::parser_t parser6(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        rm.ret = callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value(), parser5.value(), parser6.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) {
            message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            addr.send(&m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6), arg7(arg7) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        const arg7_t &arg7;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<arg5_t>::write(p, arg5);
            format_t<arg6_t>::write(p, arg6);
            format_t<arg7_t>::write(p, arg7);
        }
        int ser_size() {
             int size = 0;
            size += format_t<arg0_t>::get_size(arg0);
            size += format_t<arg1_t>::get_size(arg1);
            size += format_t<arg2_t>::get_size(arg2);
            size += format_t<arg3_t>::get_size(arg3);
            size += format_t<arg4_t>::get_size(arg4);
            size += format_t<arg5_t>::get_size(arg5);
            size += format_t<arg6_t>::get_size(arg6);
            size += format_t<arg7_t>::get_size(arg7);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        typename format_t<arg5_t>::parser_t parser5(p);
        typename format_t<arg6_t>::parser_t parser6(p);
        typename format_t<arg7_t>::parser_t parser7(p);
        p->done();
        callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value(), parser5.value(), parser6.value(), parser7.value());
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        arg3_t arg3(m->arg3);
        arg4_t arg4(m->arg4);
        arg5_t arg5(m->arg5);
        arg6_t arg6(m->arg6);
        arg7_t arg7(m->arg7);
        callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            struct : public cluster_mailbox_t, public promise_t<bool>, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    pulse(true);
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6), arg7(arg7) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        const arg7_t &arg7;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<arg5_t>::write(p, arg5);
            format_t<arg6_t>::write(p, arg6);
            format_t<arg7_t>::write(p, arg7);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<arg3_t>::get_size(arg3);
             size += format_t<arg4_t>::get_size(arg4);
             size += format_t<arg5_t>::get_size(arg5);
             size += format_t<arg6_t>::get_size(arg6);
             size += format_t<arg7_t>::get_size(arg7);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        typename format_t<arg5_t>::parser_t parser5(p);
        typename format_t<arg6_t>::parser_t parser6(p);
        typename format_t<arg7_t>::parser_t parser7(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value(), parser5.value(), parser6.value(), parser7.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);
            struct : public cluster_mailbox_t, public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    typename format_t<ret_t>::parser_t parser(p);
                    pulse(std::make_pair(true, parser.value()));
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    pulse(std::make_pair(true, m->ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6), arg7(arg7) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        const arg7_t &arg7;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<arg5_t>::write(p, arg5);
            format_t<arg6_t>::write(p, arg6);
            format_t<arg7_t>::write(p, arg7);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<arg3_t>::get_size(arg3);
             size += format_t<arg4_t>::get_size(arg4);
             size += format_t<arg5_t>::get_size(arg5);
             size += format_t<arg6_t>::get_size(arg6);
             size += format_t<arg7_t>::get_size(arg7);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            format_t<ret_t>::write(p, ret);
        }
        int ser_size() {
             return format_t<ret_t>::get_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        typename format_t<arg5_t>::parser_t parser5(p);
        typename format_t<arg6_t>::parser_t parser6(p);
        typename format_t<arg7_t>::parser_t parser7(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        rm.ret = callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value(), parser5.value(), parser6.value(), parser7.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7);
        m->reply_to.send(&rm);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t, class arg8_t>
class async_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > : private cluster_mailbox_t {

public:
    async_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(async_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) {
            message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            addr.send(&m);
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
        cluster_address_t addr;
      public:
        bool same_as(const address_t &other_addr) {
            return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
        }
    };
    friend class address_t;

private:
    struct message_t : public cluster_message_t {
        message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6), arg7(arg7), arg8(arg8) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        const arg7_t &arg7;
        const arg8_t &arg8;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<arg5_t>::write(p, arg5);
            format_t<arg6_t>::write(p, arg6);
            format_t<arg7_t>::write(p, arg7);
            format_t<arg8_t>::write(p, arg8);
        }
        int ser_size() {
             int size = 0;
            size += format_t<arg0_t>::get_size(arg0);
            size += format_t<arg1_t>::get_size(arg1);
            size += format_t<arg2_t>::get_size(arg2);
            size += format_t<arg3_t>::get_size(arg3);
            size += format_t<arg4_t>::get_size(arg4);
            size += format_t<arg5_t>::get_size(arg5);
            size += format_t<arg6_t>::get_size(arg6);
            size += format_t<arg7_t>::get_size(arg7);
            size += format_t<arg8_t>::get_size(arg8);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(message_t);
     }
#endif
    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        typename format_t<arg5_t>::parser_t parser5(p);
        typename format_t<arg6_t>::parser_t parser6(p);
        typename format_t<arg7_t>::parser_t parser7(p);
        typename format_t<arg8_t>::parser_t parser8(p);
        p->done();
        callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value(), parser5.value(), parser6.value(), parser7.value(), parser8.value());
    }

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) > callback;
    void run(cluster_message_t *cm) {
        message_t *m = static_cast<message_t *>(cm);
        arg0_t arg0(m->arg0);
        arg1_t arg1(m->arg1);
        arg2_t arg2(m->arg2);
        arg3_t arg3(m->arg3);
        arg4_t arg4(m->arg4);
        arg5_t arg5(m->arg5);
        arg6_t arg6(m->arg6);
        arg7_t arg7(m->arg7);
        arg8_t arg8(m->arg8);
        callback(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
    }
};

template<class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t, class arg8_t>
class sync_mailbox_t< void(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        void call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            struct : public cluster_mailbox_t, public promise_t<bool>, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    pulse(true);
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    pulse(true);
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(false);
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            if (!reply_listener.wait()) throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6), arg7(arg7), arg8(arg8) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        const arg7_t &arg7;
        const arg8_t &arg8;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<arg5_t>::write(p, arg5);
            format_t<arg6_t>::write(p, arg6);
            format_t<arg7_t>::write(p, arg7);
            format_t<arg8_t>::write(p, arg8);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<arg3_t>::get_size(arg3);
             size += format_t<arg4_t>::get_size(arg4);
             size += format_t<arg5_t>::get_size(arg5);
             size += format_t<arg6_t>::get_size(arg6);
             size += format_t<arg7_t>::get_size(arg7);
             size += format_t<arg8_t>::get_size(arg8);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        void serialize(cluster_outpipe_t *p) {
        }
        int ser_size() {
             return 0;
        }
    };

    boost::function< void(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        typename format_t<arg5_t>::parser_t parser5(p);
        typename format_t<arg6_t>::parser_t parser6(p);
        typename format_t<arg7_t>::parser_t parser7(p);
        typename format_t<arg8_t>::parser_t parser8(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value(), parser5.value(), parser6.value(), parser7.value(), parser8.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7, m->arg8);
        m->reply_to.send(&rm);
    }
};

template<class ret_t, class arg0_t, class arg1_t, class arg2_t, class arg3_t, class arg4_t, class arg5_t, class arg6_t, class arg7_t, class arg8_t>
class sync_mailbox_t< ret_t(arg0_t, arg1_t, arg2_t, arg3_t, arg4_t, arg5_t, arg6_t, arg7_t, arg8_t) > : private cluster_mailbox_t {

public:
    sync_mailbox_t(const boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) > &fun) :
        callback(fun) { }

    struct address_t {
        address_t() { }
        address_t(const address_t &other) : addr(other.addr) { }
        address_t(sync_mailbox_t *mb) : addr(mb) { }
        ret_t call(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) {
            call_message_t m(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8);
            struct : public cluster_mailbox_t, public promise_t<std::pair<bool, ret_t> >, public cluster_peer_t::kill_cb_t {
                void unserialize(cluster_inpipe_t *p) {
                    typename format_t<ret_t>::parser_t parser(p);
                    pulse(std::make_pair(true, parser.value()));
                    p->done();
                }
                void run(cluster_message_t *msg) {
                    ret_message_t *m = static_cast<ret_message_t *>(msg);
                    pulse(std::make_pair(true, m->ret));
                }
#ifndef NDEBUG
                const std::type_info& expected_type() {
                    return typeid(ret_message_t);
                }
#endif
                void on_kill() {
                    pulse(std::make_pair(false, ret_t()));
                }
            } reply_listener;
            m.reply_to = cluster_address_t(&reply_listener);
            cluster_t::peer_kill_monitor_t monitor(addr.get_peer(), &reply_listener);
            addr.send(&m);
            std::pair<bool, ret_t> res = reply_listener.wait();
            if (res.first) return res.second;
            else throw rpc_peer_killed_exc_t();
        }
        static void serialize(cluster_outpipe_t *p, const address_t &addr) {
            ::serialize(p, addr.addr);
        }
        static int ser_size(const address_t &addr) {
            return ::ser_size(addr.addr);
        }
        static void unserialize(cluster_inpipe_t *p, address_t *addr) {
            ::unserialize(p, &addr->addr);
        }
    private:
        cluster_address_t addr;
    public:
      bool same_as(const address_t &other_addr) {
          return (addr.mailbox == other_addr.addr.mailbox && addr.peer == other_addr.addr.peer);
      }
    };
    friend class address_t;

private:
    struct call_message_t : public cluster_message_t {
        call_message_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8)
            : arg0(arg0), arg1(arg1), arg2(arg2), arg3(arg3), arg4(arg4), arg5(arg5), arg6(arg6), arg7(arg7), arg8(arg8) { }
        const arg0_t &arg0;
        const arg1_t &arg1;
        const arg2_t &arg2;
        const arg3_t &arg3;
        const arg4_t &arg4;
        const arg5_t &arg5;
        const arg6_t &arg6;
        const arg7_t &arg7;
        const arg8_t &arg8;
        cluster_address_t reply_to;
        void serialize(cluster_outpipe_t *p) {
            format_t<arg0_t>::write(p, arg0);
            format_t<arg1_t>::write(p, arg1);
            format_t<arg2_t>::write(p, arg2);
            format_t<arg3_t>::write(p, arg3);
            format_t<arg4_t>::write(p, arg4);
            format_t<arg5_t>::write(p, arg5);
            format_t<arg6_t>::write(p, arg6);
            format_t<arg7_t>::write(p, arg7);
            format_t<arg8_t>::write(p, arg8);
            format_t<cluster_address_t>::write(p, reply_to);
        }
        int ser_size() {
             int size = 0;
             size += format_t<arg0_t>::get_size(arg0);
             size += format_t<arg1_t>::get_size(arg1);
             size += format_t<arg2_t>::get_size(arg2);
             size += format_t<arg3_t>::get_size(arg3);
             size += format_t<arg4_t>::get_size(arg4);
             size += format_t<arg5_t>::get_size(arg5);
             size += format_t<arg6_t>::get_size(arg6);
             size += format_t<arg7_t>::get_size(arg7);
             size += format_t<arg8_t>::get_size(arg8);
             size += format_t<cluster_address_t>::get_size(reply_to);
             return size;
        }
    };
#ifndef NDEBUG
     const std::type_info& expected_type() {
         return typeid(call_message_t);
     }
#endif

    struct ret_message_t : public cluster_message_t {
        ret_t ret;
        void serialize(cluster_outpipe_t *p) {
            format_t<ret_t>::write(p, ret);
        }
        int ser_size() {
             return format_t<ret_t>::get_size(ret);
        }
    };

    boost::function< ret_t(const arg0_t &arg0, const arg1_t &arg1, const arg2_t &arg2, const arg3_t &arg3, const arg4_t &arg4, const arg5_t &arg5, const arg6_t &arg6, const arg7_t &arg7, const arg8_t &arg8) > callback;

    void unserialize(cluster_inpipe_t *p) {
        typename format_t<arg0_t>::parser_t parser0(p);
        typename format_t<arg1_t>::parser_t parser1(p);
        typename format_t<arg2_t>::parser_t parser2(p);
        typename format_t<arg3_t>::parser_t parser3(p);
        typename format_t<arg4_t>::parser_t parser4(p);
        typename format_t<arg5_t>::parser_t parser5(p);
        typename format_t<arg6_t>::parser_t parser6(p);
        typename format_t<arg7_t>::parser_t parser7(p);
        typename format_t<arg8_t>::parser_t parser8(p);
        format_t<cluster_address_t>::parser_t reply_parser(p);
        p->done();
        ret_message_t rm;
        rm.ret = callback(parser0.value(), parser1.value(), parser2.value(), parser3.value(), parser4.value(), parser5.value(), parser6.value(), parser7.value(), parser8.value());
        reply_parser.value().send(&rm);
    }

    void run(cluster_message_t *cm) {
        call_message_t *m = static_cast<call_message_t *>(cm);
        ret_message_t rm;
        rm.ret = callback(m->arg0, m->arg1, m->arg2, m->arg3, m->arg4, m->arg5, m->arg6, m->arg7, m->arg8);
        m->reply_to.send(&rm);
    }
};


#endif /* __CLUSTERING_RPC_HPP__ */
